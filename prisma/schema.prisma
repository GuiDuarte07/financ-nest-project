datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id String @id @default(uuid())

  email          String  @unique
  emailConfirmed Boolean @default(false)

  password String

  name String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  categories            Category[]
  accounts              Account[]
  creditCards           CreditCard[]
  expenses              Expense[]
  creditCardTransaction CreditCardTransaction[]
  cashTransaction       CashTransaction[]
}

model Account {
  id          String  @id @default(uuid())
  balance     Float
  description String
  bank        String
  color       String?
  type        String //AccountTypes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creditCards CreditCard[]

  user            User              @relation(fields: [userId], references: [id])
  userId          String
  cashTransaction CashTransaction[]
  Income          Income[]
}

model CreditCard {
  id          String @id @default(uuid())
  limit       Int
  description String
  cardBrand   String

  account   Account @relation(fields: [accountId], references: [id])
  accountId String

  type String //CreditTypes

  closeDay      Int //Dia de fechamento da fatura
  expirationDay Int // Dia de vencimento da fatura

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  creditCardTransaction CreditCardTransaction?
}

model Category {
  id String @id @default(uuid())

  name  String
  icon  String?
  color String?
  type  String //ExpeInco

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User      @relation(fields: [userId], references: [id])
  userId  String
  Expense Expense[]
  Income  Income[]
}

model Expense {
  id            String  @id @default(uuid())
  value         Float
  justForRecord Boolean @default(false) //Apenas para registro
  paymentMethod String //PaymentMethod

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String

  creditCardTransaction CreditCardTransaction?
  cashTransaction       CashTransaction?
}

model CreditCardTransaction {
  id           String   @id @default(uuid())
  name         String
  installment  Int
  purchaseDate DateTime @default(now())
  invoiceDate  DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  expense   Expense @relation(fields: [expenseId], references: [id])
  expenseId String  @unique

  creditCard   CreditCard @relation(fields: [creditCardId], references: [id])
  creditCardId String     @unique

  user   User   @relation(fields: [userId], references: [id])
  userId String
}

model CashTransaction {
  id           String   @id @default(uuid())
  name         String
  purchaseDate DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  expense   Expense @relation(fields: [expenseId], references: [id])
  expenseId String  @unique

  account   Account @relation(fields: [accountId], references: [id])
  accountId String  @unique

  user   User   @relation(fields: [userId], references: [id])
  userId String
}

model Income {
  id            String   @id @default(uuid())
  value         Float
  receivedAt    DateTime @default(now()) // Data em que o valor foi recebido
  description   String? // Nome ou descrição para a entrada
  justForRecord Boolean  @default(false) //Apenas para registro

  category    Category? @relation(fields: [category_id], references: [id])
  category_id String?
  account     Account   @relation(fields: [account_id], references: [id])
  account_id  String
  createdAt   DateTime  @default(now())
}

// Essa tabela irá rodar em um schedule para gerar novos incomes/expense
model RecorrenceBillsProcess {
  id                   String  @id @default(uuid())
  value                Float
  stopCount            Boolean @default(false)
  paymentRecurrence    String //Recurrence  Recorrência do pagamento
  dayOfPayment         Int // Dia do pagamento (se aplicável)
  rememberDayOfPayment Boolean // Se deve lembrar o dia do pagamento (se aplicável)
  type                 String //ExpeInco

  startDate DateTime @default(now())
}

// enum Recurrence {
//   daily
//   weekly
//   monthly
// }

// enum CreditTypes {
//   debit
//   credit
// }

// enum ExpeInco {
//   expense
//   income
// }

// enum AccountTypes {
//   current
//   cash
//   savings
// }

// enum PaymentMethod {
//   cash
//   creditCard
// }
